To run the code you will need a postgres connection and a sendgrid API key (mine are stored as environment variables which are inside gitignore)

Then once all of the node modules are installed everything should be good. I have it runnning on http://localhost:5000/ The port can be changed if needed via the port variable on server.js line 5.

Summary:

The Server is Setup and configured on server.js, and the Postgres connection is setup on db.js. Server.js also contains the bulk of the backend code.

All Frontend Files are Stored in the Frontend Folder.
stylesheet.css contains the CSS not written using bootstrap
index.html Is the home page. It has text on which was generated by chatGPT simply to make it look more complete. This text generation was the only AI used on the project (No AI tools used in coding).

The other 4 HTML pages all work on the same premise. They each have a form, in which the data sent is handled by a javascript file on the client side, before being sent to the server side once some simple validation has taken place (i.e password validation and making sure the account number and sort code is numeric) this is found on validation.js

The 4 html pages, their function, and the js file attatched to them are:

signup.html -> Create A New User -> supform.js (Post)
signin.html -> Sign in to an Account -> sinform.js (Post)
edit.html -> Update Bank Information of an Existing Account -> edit.js (Put)
delete.html -> Delete an Account From the System -> delete.js (Delete)

Each JS File uses Fetch with the appropriate method to send the encoded data to server.js. The data is requested from the body in each of the endpoints. The first thing that happens in each of the endpoints is a query is run using sequelize, accesing one of the 2 postgres databases (bank_information containing encrypted bank information, and company_information containing the email and password of the user whom the account belongs to). From here, in each of the endpoints there are a number of options that could happen depending on the result of the query.

Taking the put endpoint /updated for example.
1 - If the query returns null, that means there is no account, so hence no updates can be performed. 
Else the password (using bcrypt for encryption) is checked and the bank details checked verified to be valid immediatley after. (Note I have a comment in the middle of the if statement that verifies bank details that is the mockup of the Confirmation of Payee API, Unfortunatley I could not get a key but from what I can see that should work).
If the password is correct and the bank information is valid we move on to option 2
2 - Success, The information stored in the bank_information table is updated with encryted bank information
For all endpoints, there is an email sent in the success option. This uses twilios sendgrid API, and the code for sending an email can be found on modules.js along with the rest of the mockup for the Confirmation of Payee API.
3 - If the bank information input is invalid, the information is not updated
4 - Same with if the password is incorrect
5 - If there was a server error the catch block of the try catch throws the error, this is the same with every endpoint

All other endpoints work largely in the same way, returning different outcomes dependant on bank info, passwords, and wether or not the user already has an account on the database.

Also, automated tests for every single option in every single endpoint are found in the test.js file in the test folder. It uses nodes inbuilt test runner.

For every option, there is a json response send back to the client side file, which when the promise resolves sends the data to return.js (In frontend folder). This includes a status code, which a switch statement uses to produce the outcome of what the server side response was. 

Every outcome that was not successful manipulates the HTML file in order to tell the user what the issue was with the request.

Every outcome that was succesful renders a new specific get endpoint found on server.js, one for each succesful outcome. These get requests render the EJS file found in the Views folder with text (again chatGPT generated for sake of aesthetics), as well as a word to identify which images should be placed on the page